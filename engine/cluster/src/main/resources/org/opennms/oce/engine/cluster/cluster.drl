/*******************************************************************************
 * This file is part of OpenNMS(R).
 *
 * Copyright (C) 2019 The OpenNMS Group, Inc.
 * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.
 *
 * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.
 *
 * OpenNMS(R) is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License,
 * or (at your option) any later version.
 *
 * OpenNMS(R) is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with OpenNMS(R).  If not, see:
 *      http://www.gnu.org/licenses/
 *
 * For more information contact:
 *     OpenNMS(R) Licensing <license@opennms.org>
 *     http://www.opennms.org/
 *     http://www.opennms.com/
 *******************************************************************************/

package org.opennms.oce.engine.cluster;

import java.util.Date;
import org.kie.api.time.SessionClock;
import java.util.LinkedList;
import org.apache.commons.math3.ml.clustering.Cluster;
import java.util.List;
import org.opennms.oce.datasource.api.AlarmFeedback;
import org.opennms.oce.datasource.common.ImmutableSituation;
import org.opennms.oce.datasource.api.FeedbackType;
import org.opennms.oce.datasource.api.Alarm;
import org.opennms.oce.datasource.api.Situation;
import org.opennms.oce.engine.cluster.drools.DroolsService;
import java.util.Set
import java.util.HashSet
import java.util.UUID;

global org.opennms.oce.engine.cluster.drools.DroolsService svc;

declare org.opennms.oce.engine.cluster.CEVertex
    @role(fact)
end

declare org.opennms.oce.engine.cluster.CEAlarm
    @role(event)
    @timestamp(time)
end

declare org.opennms.oce.datasource.api.AlarmFeedback
    @role(event)
    @timestamp(timestamp)
    @expires(7d)
end

rule "gc cleared alarms" salience 100
 // agenda-group "pre-correlation"
  when
    $alarm : CEAlarm( alarm.isClear() == true )
    not( CEAlarm( this == $alarm ) over window:time( 5m ) )
  then
    svc.debug("GCing cleared alarm: {}", $alarm);
    svc.garbageCollectAlarm($alarm);
end

rule "gc problem alarms" salience 100
 // agenda-group "pre-correlation"
  when
    $alarm : CEAlarm( alarm.isClear() == false )
    not( CEAlarm( this == $alarm ) over window:time( 2h ) )
  then
    svc.debug("GCing problem alarm: {}", $alarm);
    svc.garbageCollectAlarm($alarm);
end

rule "trigger dbscan"
 // agenda-group "correlation"
  when
    $alarms : LinkedList( size > 0 ) from collect ( CEAlarm() )
  then
    svc.debug("Triggering DB-Scan for {} alarms.", $alarms.size());
    List<CECluster> clustersOfAlarms = svc.cluster($alarms);
    for (CECluster cluster : clustersOfAlarms) {
        insert(cluster);
    }
    svc.debug("DB-Scan found {} clusters.", clustersOfAlarms.size());
end

rule "create a new situation for a cluster that contains alarms not previously attached to a situation"
 // agenda-group "correlation"
  when
   $cluster : CECluster()
   $alarmIdsInSituations : Set() from accumulate( Situation( $alarmIds : alarmIds ), collectFlatSet($alarmIds) )
   // Gather the list of alarms that are in the cluster and select those that are not currently in a situation
   $alarmsInClusterWithoutSituation : LinkedList( size >= 2 ) from collect( CEAlarm( id not memberOf $alarmIdsInSituations ) from $cluster.alarms )
   // Only process the cluster when none of it's alarms are in a situation
   CECluster( this == $cluster, alarms.size() == $alarmsInClusterWithoutSituation.size() )
 then
   svc.debug("Creating new situation for {} alarms.", $alarmsInClusterWithoutSituation.size());

   String situationId = UUID.randomUUID().toString();
   ImmutableSituation.Builder builder = ImmutableSituation.newBuilder()
         // Use the current clock time
        .setCreationTime(drools.getWorkingMemory().getSessionClock().getCurrentTime())
        .setId(situationId);
   for (Object alarmObj : $alarmsInClusterWithoutSituation) {
       CEAlarm alarm = (CEAlarm)alarmObj;
       builder.addAlarm(alarm.getAlarm());
   }

   insert(builder);
   // svc.associateAlarmsWithSituation($alarmsInClusterWithoutSituation, situationId);
   // Don't process the cluster again
   delete($cluster);
end

rule "update existing situations for cluster that contains alarms which were already attached to one or more situations"
 // agenda-group "correlation"
  when
   $cluster : CECluster()
   $alarmIdsInSituations : Set() from accumulate( Situation( $alarmIds : alarmIds ), collectFlatSet($alarmIds) )
   // Gather the list of alarms that are in the cluster and select those that are not currently in a situation
   $alarmsInClusterWithoutSituation : LinkedList( size >= 1 ) from collect( CEAlarm( id not memberOf $alarmIdsInSituations ) from $cluster.alarms )
   // Gather the list of alarms that are in the cluster and select those that are already in another situation
   $alarmsInClusterWithSituation : LinkedList( size >= 1 ) from collect( CEAlarm( id memberOf $alarmIdsInSituations ) from $cluster.alarms )
   // Gather the existing situations referenced by the alarms
   $allSituations : LinkedList() from collect( Situation() )
   $situationIds : Set( size >= 1 ) from accumulate( CEAlarm( id memberOf $alarmIdsInSituations, $id : id ), collectSet( getSituationIdForAlarmId($allSituations, $id) ) )
   $situations : LinkedList( size >= 1 ) from collect( Situation( id memberOf $situationIds ) )
   // Gather existing feedback relating to the situations
   $feedback : LinkedList() from collect( AlarmFeedback( situationId memberOf $situationIds ) )
   // And any existing builders that may be "in-flight"
   $builders : LinkedList() from collect( ImmutableSituation.Builder( id memberOf $situationIds ) )
 then
   svc.debug("Updating {} situation(s) with {} alarms.", $situations.size(), $alarmsInClusterWithoutSituation.size());
   List<ImmutableSituation.Builder> newOrUpdatedBuilders = svc.mapClusterToExistingSituations(
           $alarmsInClusterWithoutSituation,
           $alarmsInClusterWithSituation,
           $situations,
           $feedback,
           $builders);

   for (ImmutableSituation.Builder newOrUpdatedBuilder : newOrUpdatedBuilders) {
       if ($builders.contains(newOrUpdatedBuilder)) {
           update(newOrUpdatedBuilder);
       } else {
           insert(newOrUpdatedBuilder);
       }
   }

   // Don't process the cluster again
   delete($cluster);
end

rule "handle false positive feedback for non-pending situations"
 // agenda-group "correlation"
  when
   $feedback: AlarmFeedback( feedbackType == FeedbackType.FALSE_POSITIVE )
   $existingSituationWithFeedback: Situation( id == $feedback.situationId, alarmIds contains $feedback.alarmKey )
   not( ImmutableSituation.Builder( id == $feedback.situationId ) )
  then
   svc.debug("Got feedback for non-pending situation: {}", $feedback);
   ImmutableSituation.Builder builder = ImmutableSituation.newBuilderFrom($existingSituationWithFeedback);

   // Remove the alarm in question
   Set<Alarm> prevAlarms = $existingSituationWithFeedback.getAlarms();
   Set<Alarm> newAlarms = new HashSet<>(prevAlarms);
   newAlarms.removeIf(alarm -> alarm.getId().equals($feedback.getAlarmKey()));
   builder.setAlarms(newAlarms);

   insert(builder);
end

rule "handle false positive feedback for pending situations"
 // agenda-group "correlation"
  when
   $feedback: AlarmFeedback( feedbackType == FeedbackType.FALSE_POSITIVE )
   $existingSituationWithFeedback: Situation( id == $feedback.situationId, alarmIds contains $feedback.alarmKey )
   $builder : ImmutableSituation.Builder( id == $feedback.situationId, alarmIds contains $feedback.alarmKey )
  then
   svc.debug("Got feedback for pending situation: {}", $feedback);

   // Remove the alarm in question
   $builder.removeAlarm($feedback.getAlarmKey());

   update($builder);
end

rule "commit builder" salience -100
 // agenda-group "post-correlation"
  when
    $builder : ImmutableSituation.Builder()
  then
    svc.debug("Committing builder for situation id: {} with alarm ids: {}", $builder.getId(), $builder.getAlarmIds());
    // Update the diagnostic text
    $builder.setDiagnosticText(getDiagnosticTextForSituation(svc, $builder.build()));
    svc.createOrUpdateSituation($builder);
    delete($builder);
end

rule "cleanup dbscan" salience -100
 // agenda-group "post-correlation"
  when
    $clusters : LinkedList( size > 0 ) from collect ( Cluster() )
  then
    svc.debug("Cleaning up DB-Scan clusters.");
    for (Object cluster : $clusters) {
        delete(cluster);
    }
end

// Helper functions

function String getSituationIdForAlarmId(List situations, String alarmId) {
    for (Object situationObj : situations) {
      Situation situation = (Situation)situationObj;
      if (situation.getAlarmIds().contains(alarmId)) {
        return situation.getId();
      }
    }
    return null;
}

function String getDiagnosticTextForSituation(DroolsService svc, Situation situation) {
    long minTime = Long.MAX_VALUE;
    long maxTime = Long.MIN_VALUE;
    Double maxSpatialDistance = null;

    final Set<Long> vertexIds = new HashSet<>();
    for (Alarm alarm : situation.getAlarms()) {
        minTime = Math.min(minTime, alarm.getTime());
        maxTime = Math.max(maxTime, alarm.getTime());
        // The alarm may no longer be on the graph
        svc.getOptionalVertexIdForAlarm(alarm).ifPresent(vertexIds::add);
    }

    if (vertexIds.size() < 10) {
        maxSpatialDistance = 0d;
        for (Long vertexIdA : vertexIds) {
            for (Long vertexIdB : vertexIds) {
                if (!vertexIdA.equals(vertexIdB)) {
                    maxSpatialDistance = Math.max(maxSpatialDistance, svc.getSpatialDistanceBetween(vertexIdA, vertexIdB));
                }
            }
        }
    }

    String diagText = String.format("The %d alarms happened within %.2f seconds across %d vertices",
            situation.getAlarms().size(), Math.abs(maxTime - minTime) / 1000d, vertexIds.size());
    if (maxSpatialDistance != null && maxSpatialDistance > 0) {
        diagText += String.format(" %.2f distance apart", maxSpatialDistance);
    }
    diagText += ".";
    return diagText;
}

/*******************************************************************************
 * This file is part of OpenNMS(R).
 *
 * Copyright (C) 2019 The OpenNMS Group, Inc.
 * OpenNMS(R) is Copyright (C) 1999-2019 The OpenNMS Group, Inc.
 *
 * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.
 *
 * OpenNMS(R) is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License,
 * or (at your option) any later version.
 *
 * OpenNMS(R) is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with OpenNMS(R).  If not, see:
 *      http://www.gnu.org/licenses/
 *
 * For more information contact:
 *     OpenNMS(R) Licensing <license@opennms.org>
 *     http://www.opennms.org/
 *     http://www.opennms.com/
 *******************************************************************************/

package org.opennms.oce.engine.cluster;

import java.util.Date;
import org.kie.api.time.SessionClock;
import java.util.LinkedList;
import org.apache.commons.math3.ml.clustering.Cluster;
import java.util.List;
import org.opennms.oce.datasource.api.AlarmFeedback;
import org.opennms.oce.datasource.common.ImmutableSituation;
import org.opennms.oce.datasource.api.FeedbackType;
import org.opennms.oce.datasource.api.Alarm;
import org.opennms.oce.datasource.api.Situation;
import java.util.Set
import java.util.HashSet
import java.util.UUID;

global org.opennms.oce.engine.cluster.DroolsService svc;

declare org.opennms.oce.engine.cluster.CEVertex
    @role(fact)
end

declare org.opennms.oce.engine.cluster.CEAlarm
    @role(event)
    @timestamp(time)
end

rule "gc cleared alarms" salience 10
  when
    $alarm : CEAlarm(alarm.isClear() == true)
    not( CEAlarm( this == $alarm ) over window:time( 5m ) )
  then
    svc.debug("GCing cleared alarm: {}", $alarm);
    svc.garbageCollectAlarm($alarm);
end

rule "gc problem alarms" salience 10
  when
    $alarm : CEAlarm(alarm.isClear() == false)
    not( CEAlarm( this == $alarm ) over window:time( 2h ) )
  then
    svc.debug("GCing problem alarm: {}", $alarm);
    svc.garbageCollectAlarm($alarm);
end

rule "trigger dbscan"
  when
    $alarms : LinkedList( size > 0 ) from collect ( CEAlarm() )
  then
    svc.debug("Triggering DB-Scan for {} alarms.", $alarms.size());
    List<CECluster> clustersOfAlarms = svc.cluster($alarms);
    for (CECluster cluster : clustersOfAlarms) {
        insert(cluster);
    }
    svc.debug("DB-Scan found {} clusters.", clustersOfAlarms.size());
end

rule "create a new situation for a cluster that contains alarms not previously attached to a situation"
 when
   $cluster : CECluster()
   $map : AlarmToSituationMap()
   $context : TickContext()
   // Gather the list of alarms that are in the cluster and select those that are not currently in a situation
   $alarmsInClusterWithoutSituation : LinkedList( size >= 2 ) from collect( CEAlarm(id not memberOf $map.alarmIdsInSituations ) from $cluster.alarms )
   // Only process the cluster when none of it's alarms are in a situation
   CECluster( this == $cluster, alarms.size() == $alarmsInClusterWithoutSituation.size() )
 then
   svc.debug("Creating new situation for {} alarms.", $alarmsInClusterWithoutSituation.size());
   svc.mapClusterToNewSituation($alarmsInClusterWithoutSituation, $context);
   update($context);
   // Don't process the cluster again
   delete($cluster);
end

rule "update existing situations for cluster that contains alarms which were already attached to one or more situations"
 when
   $cluster : CECluster()
   $map : AlarmToSituationMap()
   $context : TickContext()
   // Gather the list of alarms that are in the cluster and select those that are not currently in a situation
   $alarmsInClusterWithoutSituation : LinkedList( size >= 1 ) from collect( CEAlarm( id not memberOf $map.alarmIdsInSituations ) from $cluster.alarms )
   // Gather the list of alarms that are in the cluster and select those that are already in another situation
   $alarmsInClusterWithSituation : LinkedList( size >= 1 ) from collect( CEAlarm( id memberOf $map.alarmIdsInSituations ) from $cluster.alarms )
   $situationIds : Set() from accumulate( CEAlarm( id memberOf $map.alarmIdsInSituations, $id : id ), collectSet( $map.getSituationIdForAlarmId($id) ) )
   $situations : LinkedList( size >= 1 ) from collect( Situation( id memberOf $situationIds ) )
 then
   svc.debug("Updating {} situation(s) with {} alarms.", $situations.size(), $alarmsInClusterWithoutSituation.size());
   svc.mapClusterToExistingSituations($alarmsInClusterWithoutSituation, $alarmsInClusterWithSituation, $situations, $map, $context);
   update($context);
   // Don't process the cluster again
   delete($cluster);
end

rule "handle false positive feedback for non-pending situations"
  when
   $feedback: AlarmFeedback(feedbackType == FeedbackType.FALSE_POSITIVE)
   $existingSituationWithFeedback: Situation(id == $feedback.situationId, alarmIds contains $feedback.alarmKey)
   $context : TickContext()
   not(ImmutableSituation.Builder(id == $feedback.situationId))
  then
   svc.debug("Got feedback for non-pending situation: {}", $feedback);
   ImmutableSituation.Builder situationBuilder = $context.getBuilderForExistingSituation($existingSituationWithFeedback);

   // Remove the alarm in question
   Set<Alarm> prevAlarms = $existingSituationWithFeedback.getAlarms();
   Set<Alarm> newAlarms = new HashSet<>(prevAlarms);
   newAlarms.removeIf(alarm -> alarm.getId().equals($feedback.getAlarmKey()));
   situationBuilder.setAlarms(newAlarms);

   // Remove the association
   svc.disassociateAlarmFromSituation($feedback.getAlarmKey(), $existingSituationWithFeedback.getId());

   update($context);
   insert(situationBuilder);
end

rule "handle false positive feedback for pending situations"
  when
   $feedback: AlarmFeedback(feedbackType == FeedbackType.FALSE_POSITIVE)
   $existingSituationWithFeedback: Situation(id == $feedback.situationId, alarmIds contains $feedback.alarmKey)
   $builder : ImmutableSituation.Builder(id == $feedback.situationId, alarmIds contains $feedback.alarmKey)
  then
   svc.debug("Got feedback for pending situation: {}", $feedback);

   // Remove the alarm in question
   $builder.removeAlarm($feedback.getAlarmKey());

   update($builder);
end

rule "commit context" salience -10
  when
    $context : TickContext()
  then
    svc.debug("Committing new/updated situations in the context...");
    for (Situation situation : $context.getNewOrUpdatedSituations()) {
       svc.createOrUpdateSituation(situation);
    }
    delete($context);
end

rule "cleanup dbscan" salience -10
  when
    $clusters : LinkedList( size > 0 ) from collect ( Cluster() )
  then
    svc.debug("Cleaning up DB-Scan clusters.");
    for (Object cluster : $clusters) {
        delete(cluster);
    }
end
